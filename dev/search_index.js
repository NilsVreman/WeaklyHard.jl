var documenterSearchIndex = {"docs":
[{"location":"man/summary/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/summary/","page":"Index","title":"Index","text":"","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/#Building-Automata","page":"Examples","title":"Building Automata","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Generates the automaton representations of the constraints AnyHitConstraint(1, 3) and RowHitConstraint(2, 6).","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"# Constraints\nlambda1 = AnyHitConstraint(1, 3)\nlambda2 = RowHitConstraint(2, 6)\n\n# Check dominance\nis_dominant(lambda1, lambda2) # false\nis_dominant(lambda2, lambda1) # false\n\n# Generate automaton for lambda1\nG1 = build_automaton(lambda1) \n\n# This generates the automaton:\n# Automaton{Int64} with 3 vertices:\n# {\n#         WordVertex{Int64}(100 => ---, 001) # --- is an infeasible vertex\n#         WordVertex{Int64}(010 => 100, 001)\n#         WordVertex{Int64}(001 => 010, 001)\n# } with head: WordVertex{Int64}(1 => 10, 1)\n\nG2 = build_automaton(lambda2)\n\n# This generates the automaton:\n# Automaton{Int64} with 6 vertices:\n# {\n#         WordVertex{Int64}(01100 => 11000, 00001)\n#         WordVertex{Int64}(11000 => -----, 00001)\n#         WordVertex{Int64}(01101 => 11000, 00011)\n#         WordVertex{Int64}(00011 => 00110, 00011)\n#         WordVertex{Int64}(00110 => 01100, 01101)\n#         WordVertex{Int64}(00001 => -----, 00011)\n# } with head: WordVertex{Int64}(11 => 110, 11)","category":"page"},{"location":"man/examples/#Generating-sequences-satisfying-constraints","page":"Examples","title":"Generating sequences satisfying constraints","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Generates a random sequence satisfying the constraint AnyHitConstraint(3, 5).","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"l = AnyHitConstraint(3, 5)\nG = build_automaton(l)\nN = 100_000\nseq = random_sequence(G, N)\n\nbitstring(seq)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"if the bitstring has M < N characters, it implies that the first N-M characters are misses (since julia interpret zeros before the MSB in a bit string as non-existent)","category":"page"},{"location":"man/examples/#Generating-satisfaction-set","page":"Examples","title":"Generating satisfaction set","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Generates all the sequences of length N that satisfy the constraint AnyHitConstraint(2, 3).","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"l = AnyHitConstraint(2, 3)\nG = build_automaton(l)\nN = 10\nS = all_sequences(G, N)\n\nfor s in S\n    println(bitstring(s)[end-N+1:end])\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"S is here a Set{<: Integer}, meaning we have to get the bitstring representation of the sequences in order to represent it as a sequence of deadline hits and misses.","category":"page"},{"location":"#WeaklyHard.jl-Documentation","page":"Home","title":"WeaklyHard.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WeaklyHard is a toolbox for analysing the real-time concept of weakly-hard constraints, in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, simply run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"WeaklyHard\")","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide a number of weakly-hard constraint structs, used as input to different analysis functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AnyHitConstraint(x, k): For any window of k consecutive job activations, at least x jobs hit their corresponding deadline;\nAnyMissConstraint(x, k): For any window of k consecutive job activations, at most x jobs miss their corresponding deadline;\nRowHitConstraint(x, k): For any window of k consecutive job activations, at least x consecutive jobs hit their corresponding deadline;\nRowMissConstraint(x): For any window of k consecutive job activations, at most x consecutive jobs miss their corresponding deadline.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An automaton representation of a weakly-hard constraint is a struct consisting of a record containing X amount of integers as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automaton{Int} with X vertices:\n{\n        WordVertex{Int}(x => y, z)\n        ...\n} with head: WordVertex{Int}(x => y, z)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, WordVertex{Int}(x => y, z) indicates a vertex represented by an Integer type, where x is the word the vertex is representating and y, z are the direct successors corresponding to respectively a deadline miss and a deadline hit.","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/examples.md\", \"man/functions.md\", \"man/summary.md\"]\nDepth = 1","category":"page"},{"location":"man/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"man/functions/#Types-and-Structs","page":"Functions","title":"Types and Structs","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Miss\nHit\nM\nH\nWordVertex\nAbstractAutomaton\nAutomaton\nConstraint\nRowHitConstraint\nRowMissConstraint\nAnyHitConstraint\nAnyMissConstraint","category":"page"},{"location":"man/functions/#WeaklyHard.Miss","page":"Functions","title":"WeaklyHard.Miss","text":"A deadline miss – representated as UInt8(0) \n\n\n\n\n\n","category":"constant"},{"location":"man/functions/#WeaklyHard.Hit","page":"Functions","title":"WeaklyHard.Hit","text":"A deadline hit – representated as UInt8(1) \n\n\n\n\n\n","category":"constant"},{"location":"man/functions/#WeaklyHard.M","page":"Functions","title":"WeaklyHard.M","text":"A deadline miss – representated as UInt8(0) (equivalent to Miss) \n\n\n\n\n\n","category":"constant"},{"location":"man/functions/#WeaklyHard.H","page":"Functions","title":"WeaklyHard.H","text":"A deadline hit – representated as UInt8(1) (equivalent to Hit) \n\n\n\n\n\n","category":"constant"},{"location":"man/functions/#WeaklyHard.WordVertex","page":"Functions","title":"WeaklyHard.WordVertex","text":"A struct keep track of the current node and its direct children (if some exist).\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.AbstractAutomaton","page":"Functions","title":"WeaklyHard.AbstractAutomaton","text":"Abstract representation of an automaton type \n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.Automaton","page":"Functions","title":"WeaklyHard.Automaton","text":"Automaton()\n\nAutomaton struct containing a dict to represent the vertices (including head) and transitions of the automaton.\n\nKey     = Word (represented by integer). \nValue   = WordVertex (containing current vertex and its direct children vertices)\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.Constraint","page":"Functions","title":"WeaklyHard.Constraint","text":"Abstract representation of a constraint type \n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.RowHitConstraint","page":"Functions","title":"WeaklyHard.RowHitConstraint","text":"RowHitConstraint(x, k)\n\nConstructor for RowHitConstraint.\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.RowMissConstraint","page":"Functions","title":"WeaklyHard.RowMissConstraint","text":"RowMissConstraint(x)\n\nConstructor for RowMissConstraint.\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.AnyHitConstraint","page":"Functions","title":"WeaklyHard.AnyHitConstraint","text":"AnyHitConstraint(x, k)\n\nConstructor for AnyHitConstraint.\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#WeaklyHard.AnyMissConstraint","page":"Functions","title":"WeaklyHard.AnyMissConstraint","text":"AnyMissConstraint(x, k)\n\nConstructor for AnyMissConstraint.\n\n\n\n\n\n","category":"type"},{"location":"man/functions/#Constructors-and-Functions","page":"Functions","title":"Constructors and Functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"build_automaton\ntransitions\nvertices\nis_dominant\nis_equivalent\nis_satisfied\nrandom_sequence\nall_sequences\ndominant_set\nminimize_automaton!\nbitstring(::BigInt)","category":"page"},{"location":"man/functions/#WeaklyHard.build_automaton","page":"Functions","title":"WeaklyHard.build_automaton","text":"build_automaton(Lambda::T) where {T <: Union{Constraint, Set{Constraint}}}\n\nCreates a minimal weakly-hard automaton according to the (set of) weakly-hard constraint(s) Lambda.\n\nNOTE: The function handles both single constraints and sets of constraints.\n\nExamples\n\njulia> build_automaton(AnyHitConstraint(1, 3))\nAutomaton{Int64} with 3 vertices:\n{\n\tWordVertex{Int64}(100 => ---, 001)\n\tWordVertex{Int64}(010 => 100, 001)\n\tWordVertex{Int64}(001 => 010, 001)\n} with head: WordVertex{Int64}(1 => 10, 1)\n\njulia> build_automaton(Set([AnyHitConstraint(1, 3), RowHitConstraint(2, 6)]))\nAutomaton{Int64} with 7 vertices:\n{\n\tWordVertex{Int64}(001101 => 011010, 000011)\n\tWordVertex{Int64}(000110 => 001100, 001101)\n\tWordVertex{Int64}(011001 => ------, 000011)\n\tWordVertex{Int64}(011010 => ------, 110101)\n\tWordVertex{Int64}(001100 => ------, 011001)\n\tWordVertex{Int64}(000011 => 000110, 000011)\n\tWordVertex{Int64}(110101 => ------, 000011)\n} with head: WordVertex{Int64}(11 => 110, 11)\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.transitions","page":"Functions","title":"WeaklyHard.transitions","text":"transitions(automaton::Automaton)\n\nReturns all the transitions in automaton in the form of a set of pairs where each pair consists of (v1, v2, c12), i.e., the tail of the transition v1, the head of the transition v2, and the label of the transition c12.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.vertices","page":"Functions","title":"WeaklyHard.vertices","text":"vertices(automaton::Automaton)\n\nReturns all the vertices in automaton.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.is_dominant","page":"Functions","title":"WeaklyHard.is_dominant","text":"is_dominant(l1, l2)\n\nReturns whether the weakly-hard constraint l1 dominates l2 or not.\n\nExamples\n\njulia> is_dominant(AnyHitConstraint(1, 3), RowMissConstraint(1))\nfalse\n\njulia> is_dominant(AnyHitConstraint(1, 3), RowMissConstraint(2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.is_equivalent","page":"Functions","title":"WeaklyHard.is_equivalent","text":"is_equivalent(l1, l2)\n\nReturns whether the weakly-hard constraint l1 is equivalent to l2 or not.\n\nExamples\n\njulia> is_equivalent(AnyHitConstraint(1, 3), RowMissConstraint(1))\nfalse\n\njulia> is_equivalent(AnyHitConstraint(1, 3), RowMissConstraint(2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.is_satisfied","page":"Functions","title":"WeaklyHard.is_satisfied","text":"is_satisfied(L, w)\n\nReturns whether the word w satisfies the constraint L or not; here, L can be either a single constraint or a constraint set.\n\nExamples\n\njulia> is_satisfied(AnyHitConstraint(1, 3), 595) # bitstring(595) = ...1001010011\ntrue\n\njulia> is_satisfied(AnyHitConstraint(1, 3), 600) # bitstring(600) = ...1001011000\nfalse\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.random_sequence","page":"Functions","title":"WeaklyHard.random_sequence","text":"random_sequence(automaton::Automaton, N::Integer)\n\nThe function takes an arbitrary walk of length N in automaton.  Returns a sequence that satisfy all weakly-hard constraints used to build the automaton.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.all_sequences","page":"Functions","title":"WeaklyHard.all_sequences","text":"all_sequences(automaton::Automaton, N::Integer)\n\nThe function returns a set containing all sequences of length N satisfying the constraints used to build the automaton. In other words, the function generates the satisfaction set of length N sequences.\n\nExample\n\njulia> all_sequences(build_automaton(AnyHitConstraint(2, 3)), 5)\nSet{Int8} with 9 elements:\n  22\n  13\n  15\n  29\n  27\n  31\n  30\n  14\n  23\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.dominant_set","page":"Functions","title":"WeaklyHard.dominant_set","text":"dominant_set(Lambda::Set{Constraint})\n\nCalculates the dominant constraint set given a set of weakly-hard constraints, Lambda.\n\nExamples\n\njulia> dominant_set(Set([RowMissConstraint(1), \n                         AnyMissConstraint(3, 5), \n                         AnyMissConstraint(1, 7)]))\nSet{Constraint} with 1 element:\n  AnyMissConstraint(1, 7)\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#WeaklyHard.minimize_automaton!","page":"Functions","title":"WeaklyHard.minimize_automaton!","text":"minimize_automaton!(automaton::Automaton)\n\nMinimises the automaton representation of a set of weakly-hard constraints. \n\n\n\n\n\n","category":"function"},{"location":"man/functions/#Base.bitstring-Tuple{BigInt}","page":"Functions","title":"Base.bitstring","text":"bitstring(w::BigInt [, n::Integer])\n\nA String giving the literal bit representation of a big integer w. If n is specified, it pads the bit representation to contain at least n characters.\n\nExamples\n\njulia> bitstring(BigInt(4))\n\"100\"\n\njulia> bitstring(BigInt(4), 5)\n\"00100\"\n\n\n\n\n\n","category":"method"}]
}
